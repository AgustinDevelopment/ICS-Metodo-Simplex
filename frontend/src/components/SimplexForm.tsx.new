import { useMemo, useState, useEffect } from 'react'
import { simplexService, type SimplexProblem } from '../services/simplexService'
import { useAppDispatch, useAppSelector } from '../hooks/reduxHooks'
import { setLoading, setSolution, setError, clearCurrentResult } from '../redux/slices/simplexSlice'
import {
  Box,
  Typography,
  TextField,
  Select,
  MenuItem,
  Button,
  Card,
  CardContent,
  Divider,
  Snackbar,
  Alert,
  CircularProgress,
  FormControl,
  InputLabel,
  IconButton,
  Paper,
} from "@mui/material";
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';

type Optimization = 'max' | 'min'
type Operator = '<=' | '=' | '>='

type ConstraintForm = {
  id: string
  a1: string
  a2: string
  op: Operator
  rhs: string
}

type Errors = {
  c1?: string
  c2?: string
  constraints?: Record<string, {
    a1?: string
    a2?: string
    rhs?: string
    op?: string
  }>
  general?: string
}

function isFiniteNumberStr(s: string): boolean {
  if (s.trim() === '') return false
  const n = Number(s)
  return Number.isFinite(n)
}

function newConstraint(): ConstraintForm {
  return {
    id: crypto.randomUUID(),
    a1: '',
    a2: '',
    op: '<=',
    rhs: '',
  }
}

export default function SimplexForm() {
  const dispatch = useAppDispatch()
  const { currentResult, isLoading, error: reduxError } = useAppSelector((state) => state.simplex)

  // Estado local
  const [openErrorAlert, setOpenErrorAlert] = useState(false)
  const [c1, setC1] = useState('')
  const [c2, setC2] = useState('')
  const [opt, setOpt] = useState<Optimization>('max')
  const [constraints, setConstraints] = useState<ConstraintForm[]>([newConstraint()])
  const [errors, setErrors] = useState<Errors>({})

  const constraintsErrors = errors.constraints ?? {}
  const isAlgorithmError = Boolean(currentResult && !('solution' in currentResult))
  
  function extractAlgorithmReason(msg: string): string | null {
    if (!msg) return null
    const m = msg.match(/no pudo ser resuelto:\s*(.*)$/i)
    if (m?.[1]) return m[1].trim()
    const m2 = msg.match(/:\s*(.*)$/)
    if (m2?.[1]) return m2[1].trim()
    return msg.trim() || null
  }

  const rawAlgMsg = isAlgorithmError ? ((currentResult as any).msg ?? '') : ''
  const algorithmReason = extractAlgorithmReason(rawAlgMsg)
  const alertMessage = isAlgorithmError 
    ? (algorithmReason ?? 'Por favor introduzca otros coeficientes.') 
    : ((reduxError && typeof reduxError === 'string') ? reduxError : null)

  useEffect(() => {
    setOpenErrorAlert(Boolean(alertMessage))
  }, [alertMessage])

  const isValid = useMemo(() => {
    if (!isFiniteNumberStr(c1) || !isFiniteNumberStr(c2)) return false
    if (constraints.length === 0) return false
    for (const ct of constraints) {
      if (!isFiniteNumberStr(ct.a1) || !isFiniteNumberStr(ct.a2) || !isFiniteNumberStr(ct.rhs)) return false
      if (!['<=', '=', '>='].includes(ct.op)) return false
    }
    return true
  }, [c1, c2, constraints])

  function validateAll(): Errors {
    const next: Errors = { constraints: {} }
    if (!isFiniteNumberStr(c1)) next.c1 = 'Ingrese un número válido'
    if (!isFiniteNumberStr(c2)) next.c2 = 'Ingrese un número válido'
    if (constraints.length === 0) next.general = 'Agregue al menos una restricción'
    for (const ct of constraints) {
      const e: NonNullable<Errors['constraints']>[string] = {}
      if (!isFiniteNumberStr(ct.a1)) e.a1 = 'Número inválido'
      if (!isFiniteNumberStr(ct.a2)) e.a2 = 'Número inválido'
      if (!isFiniteNumberStr(ct.rhs)) e.rhs = 'Número inválido'
      if (!['<=', '=', '>='].includes(ct.op)) e.op = 'Operador inválido'
      if (Object.keys(e).length) next.constraints![ct.id] = e
    }
    if (Object.keys(next.constraints!).length === 0) delete next.constraints
    return next
  }

  function handleAddConstraint() {
    setConstraints((prev) => [...prev, newConstraint()])
  }

  function handleRemoveConstraint(id: string) {
    setConstraints((prev) => prev.filter((c) => c.id !== id))
    setErrors((prev) => {
      if (!prev.constraints) return prev
      const rest = { ...prev.constraints }
      delete rest[id]
      return { ...prev, constraints: Object.keys(rest).length ? rest : undefined }
    })
  }

  function handleConstraintChange(id: string, patch: Partial<ConstraintForm>) {
    setConstraints((prev) => prev.map((c) => (c.id === id ? { ...c, ...patch } : c)))
  }

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    const v = validateAll()
    setErrors(v)
    if (v.c1 || v.c2 || v.general || v.constraints) return
    
    const problem: SimplexProblem = {
      name: 'Problema del formulario',
      objective: {
        type: opt,
        coefficients: [
          { value: Number(c1), variable: 'x1' },
          { value: Number(c2), variable: 'x2' }
        ]
      },
      constraints: constraints.map(ct => ({
        coefficients: [
          { value: Number(ct.a1), variable: 'x1' },
          { value: Number(ct.a2), variable: 'x2' }
        ],
        operator: ct.op,
        rightSide: Number(ct.rhs)
      })),
      variables: ['x1', 'x2']
    }

    dispatch(clearCurrentResult())
    setErrors({})
    setOpenErrorAlert(false)
    dispatch(setLoading(true))
    
    try {
      const createdProblem = await simplexService.createProblem(problem)
      const response = await simplexService.solveProblemById(createdProblem.problem.id)
      dispatch(setSolution(response))
    } catch (error: any) {
      if (error.response?.data) {
        dispatch(setError(error.response.data))
      } else {
        dispatch(setError('Error al conectar con el servidor'))
        setErrors({ general: 'Error al conectar con el servidor' })
      }
    } finally {
      dispatch(setLoading(false))
    }
  }

  return (
    <Card className="max-w-4xl mx-auto shadow-lg">
      <CardContent className="p-6">
        <Typography variant="h5" className="mb-8 text-indigo-700 font-bold text-center">
          Método Simplex (2 variables)
        </Typography>

        <form onSubmit={onSubmit} noValidate className="space-y-8">
          {/* Función Objetivo */}
          <Box className="bg-white rounded-lg p-6 shadow-sm border border-gray-100">
            <Typography variant="h6" className="text-gray-900 font-medium mb-4">
              Función Objetivo
            </Typography>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <FormControl fullWidth>
                <InputLabel id="opt-label">Optimización</InputLabel>
                <Select
                  labelId="opt-label"
                  value={opt}
                  onChange={(e) => setOpt(e.target.value as Optimization)}
                  label="Optimización"
                  className="bg-white"
                >
                  <MenuItem value="max">Maximizar</MenuItem>
                  <MenuItem value="min">Minimizar</MenuItem>
                </Select>
              </FormControl>
              <TextField
                label="Coeficiente X₁"
                type="number"
                value={c1}
                onChange={(e) => setC1(e.target.value)}
                error={!!errors.c1}
                helperText={errors.c1}
                fullWidth
                className="bg-white"
              />
              <TextField
                label="Coeficiente X₂"
                type="number"
                value={c2}
                onChange={(e) => setC2(e.target.value)}
                error={!!errors.c2}
                helperText={errors.c2}
                fullWidth
                className="bg-white"
              />
            </div>
          </Box>

          {/* Restricciones */}
          <Box className="bg-gray-50 rounded-lg p-6 shadow-sm border border-gray-100">
            <Typography variant="h6" className="text-gray-900 font-medium mb-4">
              Restricciones
            </Typography>
            {errors.general && (
              <Alert severity="error" className="mb-4">
                {errors.general}
              </Alert>
            )}
            <div className="space-y-3">
              {constraints.map((ct, idx) => {
                const e = constraintsErrors[ct.id] || {};
                return (
                  <Paper key={ct.id} className="p-4 bg-white rounded-lg shadow-sm">
                    <div className="grid grid-cols-1 md:grid-cols-12 gap-4 items-start">
                      <TextField
                        label="X₁"
                        type="number"
                        value={ct.a1}
                        onChange={(e) => handleConstraintChange(ct.id, { a1: e.target.value })}
                        error={!!e.a1}
                        helperText={e.a1}
                        className="md:col-span-3"
                        size="small"
                        fullWidth
                      />
                      <TextField
                        label="X₂"
                        type="number"
                        value={ct.a2}
                        onChange={(e) => handleConstraintChange(ct.id, { a2: e.target.value })}
                        error={!!e.a2}
                        helperText={e.a2}
                        className="md:col-span-3"
                        size="small"
                        fullWidth
                      />
                      <FormControl className="md:col-span-2" fullWidth size="small">
                        <InputLabel id={`op-label-${ct.id}`}>Operador</InputLabel>
                        <Select
                          labelId={`op-label-${ct.id}`}
                          value={ct.op}
                          onChange={(e) => handleConstraintChange(ct.id, { op: e.target.value as Operator })}
                          label="Operador"
                          error={!!e.op}
                        >
                          <MenuItem value="<=">≤</MenuItem>
                          <MenuItem value="=">=</MenuItem>
                          <MenuItem value=">=">≥</MenuItem>
                        </Select>
                      </FormControl>
                      <TextField
                        label="RHS"
                        type="number"
                        value={ct.rhs}
                        onChange={(e) => handleConstraintChange(ct.id, { rhs: e.target.value })}
                        error={!!e.rhs}
                        helperText={e.rhs}
                        className="md:col-span-3"
                        size="small"
                        fullWidth
                      />
                      <IconButton
                        onClick={() => handleRemoveConstraint(ct.id)}
                        disabled={constraints.length === 1}
                        className="md:col-span-1"
                        color="error"
                        size="small"
                      >
                        <DeleteIcon />
                      </IconButton>
                    </div>
                  </Paper>
                );
              })}
              <Button
                variant="outlined"
                onClick={handleAddConstraint}
                startIcon={<AddIcon />}
                fullWidth
                className="mt-4"
              >
                Agregar restricción
              </Button>
            </div>
          </Box>

          {/* Acciones */}
          <Box className="flex flex-wrap gap-4 justify-end">
            <Button
              variant="outlined"
              color="inherit"
              onClick={() => {
                setC1(""); setC2(""); setOpt("max");
                setConstraints([newConstraint()]);
                setErrors({});
                dispatch(clearCurrentResult());
              }}
              className="min-w-[120px]"
            >
              Limpiar
            </Button>
            <Button
              variant="contained"
              type="submit"
              disabled={!isValid || isLoading}
              className="min-w-[200px]"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <CircularProgress size={20} color="inherit" />
                  <span>Calculando...</span>
                </div>
              ) : (
                "Resolver"
              )}
            </Button>
          </Box>
        </form>

        {/* Resultados */}
        {currentResult && (
          <Box className="mt-8">
            {currentResult.solution ? (
              <Alert severity="success" variant="outlined" className="bg-green-50">
                <Typography variant="subtitle1" className="font-medium mb-3">
                  ✓ Problema resuelto correctamente
                </Typography>
                <Typography className="mb-2">
                  <strong>Valor óptimo:</strong>{" "}
                  {currentResult.solution.objectiveValue}
                </Typography>
                <ul className="list-disc pl-5 space-y-1">
                  {Object.entries(currentResult.solution.variables).map(
                    ([key, value]) => (
                      <li key={key} className="text-gray-700">
                        {key} = {value}
                      </li>
                    )
                  )}
                </ul>
              </Alert>
            ) : (
              <Alert severity="error" variant="outlined" className="bg-red-50">
                <Typography variant="subtitle1" className="font-medium mb-2">
                  ✗ Error al resolver problema
                </Typography>
                {((currentResult as any).status === "SIN_SOLUCION") && (
                  <Typography variant="body2" className="text-gray-700">
                    Por favor introduzca otros coeficientes.
                  </Typography>
                )}
              </Alert>
            )}
          </Box>
        )}

        <Snackbar
          open={openErrorAlert && !!alertMessage}
          autoHideDuration={6000}
          onClose={() => setOpenErrorAlert(false)}
          anchorOrigin={{ vertical: "top", horizontal: "center" }}
        >
          <Alert
            onClose={() => setOpenErrorAlert(false)}
            severity="error"
            variant="filled"
            sx={{ minWidth: 300 }}
          >
            {alertMessage}
          </Alert>
        </Snackbar>
      </CardContent>
    </Card>
  );
}